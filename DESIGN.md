#Cell Society Design
Names: Christopher Streiffer, David Zhou, Connor Usry

###Introduction
The goal of our design was to create a structure that allows for new simulation environments to be easily added to the program. As will be discussed in more detail later, our design is structured as a hierarchy, with only necessary information being exchanged between the levels. The simulations will be implemented at the lower-level classes of the program. The higher-level classes will be highly flexible in the sense that they can run the same code on any new addition at the lower levels. The code will be able to receive external input via four different methods. The first is a configuration file that will contribute variables/starting conditions to the various lower-level classes. The second is the xml files that define the initial state of each simulation. The third is a panel that the user can interact with to change parameters within the simulation. The fourth is a main screen that the user can interact with to choose the simulation to run. These will be the only open points in the code -- everything else will be self-contained. Additionally, the higher-level classes will handle the transitioning between different states in the game. We think that the design is the most important part of this assignment, as having a good design will allow for new features to easily be implemented in the later sprints. 

###Overview
![Roadmap 1](https://github.com/duke-compsci308-fall2015/cellsociety_team22/images/roadmap1.png)
![Roadmap 2](https://github.com/duke-compsci308-fall2015/cellsociety_team22/images/roadmap2.png)

The two pictures above illustrate the basic road map for the classes that will comprise our project.  In the first image, the class hierarchy is shown on the leftmost pane and the program control flow is shown in the pane that is second from the left.  We have decided to create three abstract classes to facilitate the implementation of new features.  We will describe each of the classes in detail here.

**Main**: This class is responsible for launching the program.  It creates a stage, starts the game’s loop, and initializes a GameManager.  This is the standard class that contains public static void main(String[] args).

**GameManager**:  This is the central control hub of the program, as shown in the program control flow.  After being initialized by main, GameManager will be responsible for switching the program between the different Scenes that will show up on the game’s Stage.  It will interface directly with different instances of the Screen class.  It will have a class Screen variable that points to the currently loaded Screen.  Its relevant methods include checkState(), which will return null if the current Screen is still running and a pointer to the next Screen if it is done; load(), which will load a new Screen’s scene into the Stage; init(), which will load the Scene of the Start class by default when the GameManager is created(); and run(), which is the loop of this class that constantly checks if checkState() returns null, and load()s the appropriate Screen when it does not.

**(abstract) Screen**: this is a wrapper class for the Scenes that are placed on the game’s stage.  It represents the different screens that should appear on the computer monitor.  Its variables include myScene, a scene that will be given to GameManager to be loaded onto the Stage, and nextScreen, a pointer to the next Screen to be loaded.  Initially, this variable will be set to null and only when a Screen is done running will it set its nextScreen variable.  The GameManager will constantly be checking this variable using the getter method for this variable.  Finally, we also intend to include the method signature for a run() method at this level, which will be a loop that handles button input and moves simulation Screens along.  This class exists so that we can create any kind of Screen we might want to add to the program, such as a settings page or a credits page.

**(abstract) Grid**: this is another abstract class that extends Screen.  It generalizes what each simulation should have in common and is designed to be extended to create the various game Screens that we will implement.  It contains a double array of Cells[][] and two Scenes as its variables.  The first of these Scenes represents the visual representation of the Cells[][] and indicates the current state of the simulation.  Meanwhile, the paramScene contains a visual representation of the current state of each of the parameters in the game and will have interactive elements to adjust each of them.  One of the methods of this class will combineScenes(), which will algorithmically combine both scenes together based on the size of the Cells[][] array to generate the scene that is fed into GameManager.  When a Grid is done running, it will always point GameManager back to the Start class.  At this level, we will also implement a method for parsing XML files to generate initial conditions so that implementations of this class will be able to construct themselves.  Implementations of this class will represent the different simulations that we have to implement, and implementing their run() methods will give them the rules of how to run.

**Start**:  This is another instance of the Screen class, and it is the first Screen that appears when the program is run.  This class will have a nested class Icon that represents each of the clickable buttons that link to the different simulations.  When the button of an Icon is clicked, Start will set its nextScene to the appropriate Grid Screen.  In addition, there will be a file selector or drop down menu for loading XML files.  The only variable of this class will be a list of icons.  The methods of this class include init(), which reads files and parameters from config, as well implementation(), which iteraters through all icons and places them onto the scene algorithmically depending on how many of them there are.

**Cell**:  This class will be figured out in design.  We know that it requires a method that will take its neighbors as input (which different implementations of Grid will be able to calculate) and determine its next State based on this information.  Each cell will also have a visual representation that will be stored in this class, and a name of the Cell’s state.  Cell will be an abstract class designed to be extended into all of the cells that can appear in the simulations.  If appropriate, cells can be extended multiple times to create a hierarchy. 

**Parameters***: This is a class that contains all of the parameters that a Grid needs to check to run its simulation.  Its only methods will be getters and setters for the parameters that will be adjusted by each Grid in their run() loops based on user input in the paramScene.

**Config**: This class contains a HashMap of the name of all variables to be defined throughout the program linked to the values of those variables.  It will have a method init() that reads a configurations parameters text file to build this HashMap, as well as a general getter method that gets variables from the HashMap.  This class allows us to modify any “magic values” in one place.

###User Interface

![Start Screen](https://github.com/duke-compsci308-fall2015/cellsociety_team22/images/start-screen.png)
![Simulation Screen](https://github.com/duke-compsci308-fall2015/cellsociety_team22/images/sim-screen.png)

The user interface is designed to be very straight-forward and easy to use. The user selects the simulation they want to run by clicking on the image. When the user hovers their mouse over the image, it will scroll through a series of transitions displaying what the simulation might look like. When the user clicks on an image, the corresponding xml files will be loaded into the drop-down menu. When the user selects the xml file, the simulation screen will be loaded. On this screen the user will be able to interact with the simulation through the parameter panel. The parameter panel will be unique to each simulation. The values from the parameter panel will be fed into the Grid class corresponding to the simulation, and will be applied accordingly. There will be buttons added further on that will allow for transitioning between scenes. Errors will be reported to the user when the xml file is attempted to be loaded. Any error in the xml syntax will cause the simulation screen to not load, and the user will have to fix the error or select a different xml file before proceeding. This is an initial design, and the user interface will evolve as we get further into the project. 

###Design Details and Considerations

####Assignment Specifications:
Most of the specifications in the assignment page will be handled by a Grid’s run() method; it will be responsible for the two loops that apply the rules to each cell simultaneously and then updating all states simultaneously in a second pass.  These different rules for different games will be implemented separately in an extension of the abstract class Grid for each game.
The size of the grid and initial values for the parameters can be read from an XML file by a build() method that is implemented at the abstract Grid level, as described earlier.

####Use Cases:
Apply the rules to a middle cell: set the next state of a cell to dead by counting its number of neighbors using the Game of Life rules for a cell in the middle (i.e., with all its neighbors):
For Game of Life, an extension of Grid is created.  This grid first iterates through all of the Cells in the Cell[][] array and calculates the relevant neighbors; for this class, it is all cells that have x and y indices that are +/- 1 away.  It will then ask the cell what the next State should be by passing the Cell class a list of the neighbors.  For a dead cell like this, the cell will tell the grid that it should become a live cell if and only if it has exactly three neighbors.  In a second pass, the Grid will change all of the cell states based on what their nextStates are.  This is to avoid cells that were changed earlier in the process from affecting other cells that the loop reaches later.
Apply the rules to an edge cell: set the next state of a cell to live by counting its number of neighbors using the Game of Life rules for a cell on the edge (i.e., with some of its neighbors missing):
This will be handled by the Grid’s ability to check neighbors; if the indices are out of bounds of the size of the Cell[][] array, do not include those cells within the list of neighbors given to the current Cell.  The Cell method for detecting the nextState should take a list of Cells (the neighbors) as an input and not be concerned with the length of this list.
Move to the next generation: update all cells in a simulation from their current state to their next state and display the result graphically:
Once again, this will be a separate loop.  All of the Cells should have a variable nextCell that says what the nextState should be, and these will be determined in the first loop where the neighbors are checked.  In this second loop, the Grid will delete the appropriate cells, remove them from the scene, and create new Cells based on the nextCell variables.  Then, all nextCell variables will be determined again.
Set a simulation parameter: set the value of a parameter, probCatch, for a simulation, Fire, based on the value given in an XML fire
The run() loop of a grid is constantly adjusting the parameter values based on user input to the ParamScene of the grid’s scene.  The initial value can also be adjusted in the XML file; this will change how the grid specific to this game will be initialized when it parses that XML file.
Switch simulations: use the GUI to change the current simulation from Game of Life to Water
When the status of the Game of Life simulation is done (because the user clicked a button that will likely show up in the paramScene of the game), the Grid will set its nextScreen variable to Start, which will cause the GameManager to load the scene of the Start Screen.  From here, the user is free to select the next Simulation by clicking on an Icon, which will set Start’s nextScreen variable to the appropriate simulation and cause GameManager to act accordingly.

####Additional Considerations and Justifications:
We tried to make each of our classes as isolated and focused as possible so that it would be easy to debug and add new functionality.  Each of the classes has a very specific role; the GameManager is the central control hub, Screen is an abstraction of each individual Screen, Cell is an abstraction of each cell, Parameters is a class that holds variables, etc.  We believe that separating the classes this way allows for easy extension to include additional requirements through the use of inheritance and polymorphism.  New simulations can be added by creating new implementations of the abstract Grid class, new cells can be introduced by extending Cells, and even settings and credits screens can be added by extending Screen.  The config class also allows us to quickly test and change variables that define how the program runs, such as appearance and run speed.

###Team Responsibilities
Our primary responsibilities are first implementing the design described above. We are going to divide the different classes among ourselves, and finish this to completion. Once this is done, our secondary responsibility will be to each implement a simulation. 
